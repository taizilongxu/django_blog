<p>title: Node.js基础<br>
date: 2014-04-09 20:16:57<br>
category: Node.js</p>

<h2>tag: node</h2>

<h1>第一章 简介</h1>

<h2>1.1Node.js 是什么</h2>

<h3>CommonJS 规范</h3>

<p>一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。</p>
<pre><code>console.log("evaluating example.js");

var invisible = function () {
  console.log("invisible");
}

exports.message = "hi";

exports.say = function () {
  console.log(message);
}</code></pre>
<p>使用require方法，加载example.js。</p>
<pre><code>var example = require('./example.js');</code></pre>
<p>这时，变量example就对应模块中的exports对象，于是就可以通过这个变量，使用模块提供的各个方法。</p>
<pre><code>{
  message: "hi",
  say: [Function]
}</code></pre>
<p>require方法默认读取js文件，所以可以省略js后缀名。</p>
<pre><code>var example = require('./example');</code></pre>
<p>js文件名前面需要加上路径，可以是相对路径（相对于使用require方法的文件），也可以是绝对路径。如果省略路径，node.js会认为，你要加载一个核心模块，或者已经安装在本地 node_modules 目录中的模块。如果加载的是一个目录，node.js会首先寻找该目录中的 package.json 文件，加载该文件 main 属性提到的模块，否则就寻找该目录下的 index.js 文件。</p>

<p>下面的例子是使用一行语句，定义一个最简单的模块。</p>
<pre><code>// addition.js
exports.do = function(a, b){ return a + b };</code></pre>
<p>上面的语句定义了一个加法模块，做法就是在exports对象上定义一个do方法，那就是供外部调用的方法。使用的时候，只要用require函数调用即可。</p>
<pre><code>var add = require('./addition');

add.do(1,2)
// 3</code></pre>
<p>再看一个复杂一点的例子。</p>
<pre><code>// foobar.js

function foobar(){
        this.foo = function(){
                console.log('Hello foo');
        }

        this.bar = function(){
                console.log('Hello bar');
        }
}
exports.foobar = foobar;</code></pre>
<p>调用该模块的方法如下：</p>
<pre><code>var foobar = require('./foobar').foobar,
    test   = new foobar();

test.bar(); // 'Hello bar'</code></pre>
<p>有时，不需要exports返回一个对象，只需要它返回一个函数。这时，就要写成module.exports。</p>
<pre><code>module.exports = function () {
  console.log("hello world")
}</code></pre>
<h2>1.2Node能做什么？</h2>

<ul>
<li>具有复杂逻辑的网站； </li>
<li>基于社交网络的大规模 Web 应用； </li>
<li>Web Socket 服务器； </li>
<li>TCP/UDP 套接字应用程序； * </li>
<li>命令行工具； </li>
<li>交互式终端程序； </li>
<li>带有图形用户界面的本地应用程序； </li>
<li>单元测试工具； </li>
<li>客户端 JavaScript 编译器。</li>
</ul>

<h2>1.3异步式 I/O 与事件驱动</h2>

<ul>
<li>异步式 I/O: 跳过I/O直接运行下一步，不再等待I/O处理结果</li>
<li>事件驱动:事件队列，程序执行的时候进入事件循环来执行下一个事件</li>
</ul>

<h2>1.4Node.js性能</h2>

<p>比PHP性能要高很多</p>

<h2>1.5JavaScript简史</h2>

<h1>第二章 安装和配置Node.js</h1>

<h1>第三章 快速入门</h1>

<ul>
<li><p>node helloworld.js:执行js脚本</p></li>
<li><p>node 的 REPL 模式（同Python的Shell交互模式）</p></li>
</ul>

<h2>3.1创建Http服务器</h2>
<pre><code>//app.js 

var http = require('http'); 


http.createServer(function(req, res) { 

 res.writeHead(200, {'Content-Type': 'text/html'}); 

 res.write('<h1>Node.js</h1>'); 

 res.end('<p>Hello World</p>'); 

}).listen(3000); 

console.log("HTTP server is listening at port 3000.");</code></pre>
<h2>3.2使用supervisor</h2>

<ul>
<li><p>安装</p>

<p>$ npm install -g supervisor </p></li>
<li><p>使用</p>

<p>$ supervisor app.js </p></li>
<li><p>作用：开发时修改代码后会自动终止脚本，然后重新启动，方便调试。</p></li>
</ul>

<h2>3.3异步式 I/O 与事件式编程</h2>

<ul>
<li>异步I/O

<ul>
<li>优点：单线程减少开销</li>
<li>缺点：编程思维独特，难以适应</li>
</ul></li>
<li>回调函数：不鼓励用同步I/O</li>
<li>事件循环机制：Node.js 程序由事件循环开始，到事件循环结束，所有的逻辑都是事件的回调函数，所以 Node.js 始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数在执行的过程中，可能会发出 I/O 请求或直接发射（emit）事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未处理的事件，直到程序结束。</li>
</ul>

<h2>3.4模块和包</h2>

<ul>
<li>两者没有本质区别</li>
<li>文件和模块一一对应，一个Node.js文件就是一个模块</li>
</ul>

<h3>加载：</h3>

<ul>
<li>require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。 </li>
<li>exports 是模块公开的接口</li>
</ul>

<p>例子：</p>
<pre><code>//module.js 

var name; 

exports.setName = function(thyName) { 
 name = thyName; 
}; 

exports.sayHello = function() { 
 console.log('Hello ' + name); 
};</code></pre>
<p>在同一目录下创建 getmodule.js，内容是： </p>
<pre><code>//getmodule.js 
var myModule = require('./module'); 
myModule.setName('BYVoid'); 
myModule.sayHello();</code></pre>
<p>运行node getmodule.js，结果是： </p>
<pre><code>Hello BYVoid</code></pre>
<h3>单次加载</h3>

<p>这点和对象不一样，无论调用多少次 require，获得的模块都是同一个</p>
<pre><code>//loadmodule.js 
var hello1 = require('./module'); 
hello1.setName('BYVoid'); 
var hello2 = require('./module'); 
hello2.setName('BYVoid 2'); 
hello1.sayHello();</code></pre>
<p>输出结果：</p>
<pre><code>Hello BYVoid 2</code></pre>
<p>结果被后者覆盖了。</p>

<h3>覆盖exports</h3>
<pre><code>//singleobject.js 
function Hello() { 
 var name; 
 this.setName = function (thyName) { 
 name = thyName; 
 }; 
this.sayHello = function () { 
 console.log('Hello ' + name); 
 }; 
}; 
exports.Hello = Hello; 

//简化后：module.exports = Hello;</code></pre>
<p>简化前：</p>
<pre><code>require('./singleobject').Hello</code></pre>
<p>简化后可以直接获取对象：</p>
<pre><code>//gethello.js 
var Hello = require('./hello'); 
hello = new Hello(); 
hello.setName('BYVoid'); 
hello.sayHello();</code></pre>
<p><strong>exports</strong>本是就是一个空对象，本质上是通过闭包来建立一个有限的的访问接口。（很简单却想了很久～）</p>

<h2>创建包</h2>

<p>commonJS规范如下：</p>

<ul>
<li>package.json 必须在包的顶层目录下； </li>
<li>二进制文件应该在 bin 目录下； </li>
<li>JavaScript 代码应该在 lib 目录下； </li>
<li>文档应该在 doc 目录下； </li>
<li>单元测试应该在 test 目录下。</li>
</ul>

<h3>package.jason</h3>

<p>Node.js 在调用某个包时，会首先检查包中 package.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 <br>
main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。</p>

<ul>
<li>name：包的名称，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。 </li>
<li>description：包的简要说明。 </li>
<li>version：符合语义化版本识别①规范的版本字符串。 </li>
<li>keywords：关键字数组，通常用于搜索。 </li>
<li>maintainers：维护者数组，每个元素要包含 name、email （可选）、web （可选）字段。 </li>
<li>contributors：贡献者数组，格式与maintainers相同。包的作者应该是贡献者数组的第一个元素。 </li>
<li>bugs：提交bug的地址，可以是网址或者电子邮件地址。 </li>
<li>licenses：许可证数组，每个元素要包含 type （许可证的名称）和 url （链接到许可证文本的地址）字段。 </li>
<li>repositories：仓库托管地址数组，每个元素要包含 type （仓库的类型，如 git ）、url （仓库的地址）和 path （相对于
仓库的路径，可选）字段。 </li>
<li> dependencies：包的依赖，一个关联数组，由包名称和版本号组成。</li>
</ul>

<p>例子：<br>
<code><br>
{ <br>
 &quot;name&quot;: &quot;mypackage&quot;, <br>
 &quot;description&quot;: &quot;Sample package for CommonJS. This package demonstrates the required <br>
elements of a CommonJS package.&quot;, <br>
 &quot;version&quot;: &quot;0.7.0&quot;, <br>
 &quot;keywords&quot;: [ <br>
 &quot;package&quot;, <br>
 &quot;example&quot; <br>
 ], <br>
 &quot;maintainers&quot;: [ <br>
 { <br>
 &quot;name&quot;: &quot;Bill Smith&quot;, <br>
 &quot;email&quot;: &quot;bills@example.com&quot;, <br>
 } <br>
 ], <br>
 &quot;contributors&quot;: [ <br>
 { <br>
 &quot;name&quot;: &quot;BYVoid&quot;, <br>
 &quot;web&quot;: &quot;http://www.byvoid.com/&quot; <br>
 } <br>
 ], <br>
 &quot;bugs&quot;: { <br>
 &quot;mail&quot;: &quot;dev@example.com&quot;, <br>
 &quot;web&quot;: &quot;http://www.example.com/bugs&quot; <br>
 }, <br>
 &quot;licenses&quot;: [ <br>
 { <br>
 &quot;type&quot;: &quot;GPLv2&quot;, <br>
 &quot;url&quot;: &quot;http://www.example.org/licenses/gpl.html&quot; <br>
 } <br>
 ], <br>
 &quot;repositories&quot;: [ <br>
 { <br>
 &quot;type&quot;: &quot;git&quot;, <br>
 &quot;url&quot;: &quot;http://github.com/BYVoid/mypackage.git&quot; <br>
 } <br>
 ], <br>
 &quot;dependencies&quot;: { <br>
 &quot;webkit&quot;: &quot;1.2&quot;, <br>
 &quot;ssl&quot;: { <br>
 &quot;gnutls&quot;: [&quot;1.0&quot;, &quot;2.0&quot;], <br>
 &quot;openssl&quot;: &quot;0.9.8&quot; <br>
 } <br>
 } <br>
} <br>
</code></p>

<h3>包管理</h3>

<p>npm：</p>
<pre><code>npm [install/i] [package_name]</code></pre>
<ul>
<li>本地模式：默认方法，存放当前目录下</li>
<li><p>全局模式：减少重复副本</p>

<p>npm [install/i] -g [package_name] </p></li>
<li><p>创建全局链接：把全局包当成本地包来用</p>

<p>$ npm link express <br>
./node_modules/express -&gt; /usr/local/lib/node_modules/express </p></li>
</ul>

<h3>使用 node-inspector 调试 Node.js</h3>
<pre><code>npm install -g node-inspector //安装insepctor
node --debug-brk=5858 debug.js //链接服务器
$ node-inspector//启动
 http://127.0.0.1:8080/debug?port=5858 //浏览器中打开！</code></pre>